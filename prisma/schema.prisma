// Prisma Schema para Quiniela Mundial 2026

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// NextAuth Models
model Account {
    id                String  @id @default(cuid())
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String? @db.Text
    access_token      String? @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? @db.Text
    session_state     String?

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
    @@index([userId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([userId])
}

model User {
    id            String       @id @default(cuid())
    name          String?
    email         String?      @unique
    emailVerified DateTime?
    image         String?
    role          UserRole     @default(USER)
    hasPaid       Boolean      @default(false) // Si el usuario ha pagado
    paidAt        DateTime? // Fecha de pago
    createdAt     DateTime     @default(now())
    updatedAt     DateTime     @updatedAt
    accounts      Account[]
    sessions      Session[]
    predictions   Prediction[]
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

// Quiniela Models
model Team {
    id          String   @id @default(cuid())
    name        String
    code        String   @unique // CÃ³digo de 3 letras (ej: MEX, USA, BRA)
    flag        String? // URL de la bandera
    group       String? // Grupo en fase de grupos (A-H)
    createdAt   DateTime @default(now())
    homeMatches Match[]  @relation("HomeTeam")
    awayMatches Match[]  @relation("AwayTeam")
}

model Match {
    id         String      @id @default(cuid())
    homeTeamId String
    awayTeamId String
    homeTeam   Team        @relation("HomeTeam", fields: [homeTeamId], references: [id])
    awayTeam   Team        @relation("AwayTeam", fields: [awayTeamId], references: [id])
    homeScore  Int?
    awayScore  Int?
    matchDate  DateTime
    stadium    String?
    city       String?
    phase      MatchPhase
    status     MatchStatus @default(SCHEDULED)
    createdAt  DateTime    @default(now())
    updatedAt  DateTime    @updatedAt

    @@index([matchDate])
    @@index([status])
}

model Prediction {
    id        String   @id @default(cuid())
    userId    String
    matchId   String // Reference to match ID (can be from JSON data)
    phase     String? // Phase of the match for grouping points
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    homeScore Int
    awayScore Int
    points    Int      @default(0)
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([userId, matchId])
    @@index([userId])
    @@index([matchId])
    @@index([phase])
}

model GroupMatchScore {
    id        String    @id @default(cuid())
    matchId   Int       @unique // ID del partido en matches.json
    homeScore Int?
    awayScore Int?
    matchDate DateTime? // Fecha/hora personalizada (anula la del JSON)
    updatedAt DateTime  @updatedAt

    @@index([matchId])
}

model PointsRule {
    id                    String   @id @default(cuid())
    exactScore            Int      @default(5) // Puntos por marcador exacto
    correctWinner         Int      @default(3) // Puntos por acertar ganador
    correctDraw           Int      @default(3) // Puntos por acertar empate
    correctGoalDifference Int      @default(2) // Puntos por acertar diferencia de goles
    isActive              Boolean  @default(true)
    createdAt             DateTime @default(now())
    updatedAt             DateTime @updatedAt

    @@index([isActive])
}

// Enums
enum UserRole {
    USER
    ADMIN
}

enum MatchPhase {
    GROUP_STAGE
    ROUND_OF_32
    ROUND_OF_16
    QUARTER_FINAL
    SEMI_FINAL
    THIRD_PLACE
    FINAL
}

enum MatchStatus {
    SCHEDULED
    LIVE
    FINISHED
    POSTPONED
    CANCELLED
}
